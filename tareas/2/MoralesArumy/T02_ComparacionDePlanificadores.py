# -*- coding: utf-8 -*-
"""T02_ComparacionDePlanificadores.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c7P0De7w5xvHCNAWJlvrUcI3FXFcRrNS
"""

import random
import statistics
import string
from copy import deepcopy

def generar_ronda(num_pro=None, llegada_gap_max=3, servicio_min=1, servicio_max=6):
    if num_pro is None:
        num_pro = random.randint(4, 6)
    procesos = []
    t = 0
    for i in range(num_pro):
        gap = random.randint(0, llegada_gap_max)
        t += gap
        dur = random.randint(servicio_min, servicio_max)
        procesos.append({
            'nombre': string.ascii_uppercase[i],
            'inicio': t,
            'servicio': dur,
            'rest': dur,
            'fin': None
        })
    return procesos

def timeline_to_str(tl):
    return ''.join(tl)

def estado_ejecucion(proceso_inicial):
    proceso = deepcopy(proceso_inicial)
    for p in proceso:
        p['rest'] = p['servicio']
        p['fin'] = None
    return proceso

def calcular_metricas(pro):
    T = []
    E = []
    P = []
    for p in pro:
        fin = p.get('fin')
        if fin is None:
            continue
        t = fin - p['inicio']
        e = t - p['servicio']
        pen = t / p['servicio'] if p['servicio'] > 0 else 0
        T.append(t)
        E.append(e)
        P.append(pen)
    if not T:
        return (0.0, 0.0, 0.0)
    return (round(statistics.mean(T),3), round(statistics.mean(E),3), round(statistics.mean(P),3))

def fcfs(proceso_inicial):
    pro = estado_ejecucion(proceso_inicial)
    pro_sorted = sorted(pro, key=lambda x: (x['inicio'], x['nombre']))
    time = 0
    timeline = []
    for p in pro_sorted:
        if time < p['inicio']:
            idle_len = p['inicio'] - time
            timeline.extend(['-'] * idle_len)
            time = p['inicio']
        timeline.extend([p['nombre']] * p['servicio'])
        time += p['servicio']
        p['fin'] = time
    metricas = calcular_metricas(pro_sorted)
    return metricas, timeline, pro_sorted

def rr(proceso_inicial, quantum=1):
    pro = estado_ejecucion(proceso_inicial)
    time = 0
    timeline = []
    ready = []
    incoming = sorted(pro, key=lambda x: x['inicio'])
    idx_in = 0
    while True:
        while idx_in < len(incoming) and incoming[idx_in]['inicio'] <= time:
            ready.append(incoming[idx_in])
            idx_in += 1
        if not ready:
            if idx_in < len(incoming):
                next_inicio = incoming[idx_in]['inicio']
                gap = next_inicio - time
                timeline.extend(['-'] * gap)
                time = next_inicio
                continue
            else:
                break
        p = ready.pop(0)
        run = min(quantum, p['rest'])
        timeline.extend([p['nombre']] * run)
        time += run
        p['rest'] -= run
        while idx_in < len(incoming) and incoming[idx_in]['inicio'] <= time:
            ready.append(incoming[idx_in])
            idx_in += 1
        if p['rest'] > 0:
            ready.append(p)
        else:
            p['fin'] = time
    metricas = calcular_metricas(pro)
    return metricas, timeline, pro

def spn(proceso_inicial):
    pro = estado_ejecucion(proceso_inicial)
    time = 0
    timeline = []
    nuevo = sorted(pro, key=lambda x: x['inicio'])
    ready = []
    idx_in = 0
    while True:
        while idx_in < len(nuevo) and nuevo[idx_in]['inicio'] <= time:
            ready.append(nuevo[idx_in])
            idx_in += 1
        if not ready:
            if idx_in < len(nuevo):
                next_arr = nuevo[idx_in]['inicio']
                gap = next_arr - time
                timeline.extend(['-'] * gap)
                time = next_arr
                continue
            else:
                break
        ready.sort(key=lambda x: (x['servicio'], x['inicio'], x['nombre']))
        p = ready.pop(0)
        timeline.extend([p['nombre']] * p['servicio'])
        time += p['servicio']
        p['rest'] = 0
        p['fin'] = time
    metricas = calcular_metricas(pro)
    return metricas, timeline, pro

def fb(proceso_inicial, quantums=[1,2,4]):
    pro = estado_ejecucion(proceso_inicial)
    time = 0
    timeline = []
    num_levels = len(quantums)
    queues = [[] for _ in range(num_levels)]
    incoming = sorted(pro, key=lambda x: x['inicio'])
    idx_in = 0

    def a単adir_inicio(upto_time):
        nonlocal idx_in
        while idx_in < len(incoming) and incoming[idx_in]['inicio'] <= upto_time:
            queues[0].append(incoming[idx_in])
            idx_in += 1

    while True:
        a単adir_inicio(time)
        level = None
        for l in range(num_levels):
            if queues[l]:
                level = l
                break
        if level is None:
            if idx_in < len(incoming):
                next_arr = incoming[idx_in]['inicio']
                gap = next_arr - time
                timeline.extend(['-'] * gap)
                time = next_arr
                a単adir_inicio(time)
                continue
            else:
                break
        p = queues[level].pop(0)
        q = quantums[level]
        run = min(q, p['rest'])
        timeline.extend([p['nombre']] * run)
        time += run
        p['rest'] -= run
        a単adir_inicio(time)
        if p['rest'] > 0:
            if run == q and level < num_levels - 1:
                queues[level + 1].append(p)
            else:
                queues[level].append(p)
        else:
            p['fin'] = time
    metricas = calcular_metricas(pro)
    return metricas, timeline, pro

def encabezado(round_idx, pro):
    print(f"Ronda {round_idx+1}:")
    s = "; ".join([f"{p['nombre']}: {p['inicio']}, t={p['servicio']}" for p in pro])
    total = sum(p['servicio'] for p in pro)
    print("  " + s + f"  (total:{total})")

def resultados(nombre, metricas, timeline):
    T, E, P = metricas
    print(f"{nombre}: T={T}, E={E}, P={P}")
    print("   " + timeline_to_str(timeline))

def main(rounds=5, seed=None):
    if seed is not None:
        random.seed(seed)
    for r in range(rounds):
        proceso = generar_ronda()
        p_spec = deepcopy(proceso)
        encabezado(r, p_spec)

        m_fcfs, tl_fcfs, _ = fcfs(p_spec)
        resultados("FCFS", m_fcfs, tl_fcfs)

        m_rr1, tl_rr1, _ = rr(p_spec, quantum=1)
        resultados("RR1", m_rr1, tl_rr1)

        m_rr4, tl_rr4, _ = rr(p_spec, quantum=4)
        resultados("RR4", m_rr4, tl_rr4)

        m_spn, tl_spn, _ = spn(p_spec)
        resultados("SPN", m_spn, tl_spn)

        m_fb, tl_fb, _ = fb(p_spec, quantums=[1,2,4])
        resultados("FB", m_fb, tl_fb)
        print("")

if __name__ == "__main__":
    main(rounds=5, seed=None)